"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildEmoji = void 0;
exports.clearCache = clearCache;
exports.setOptions = setOptions;
exports.raw = raw;
exports.post = post;
exports.topic = topic;
exports.topics = topics;
exports.postSummaries = postSummaries;
exports.notifications = notifications;
exports.header = header;
exports.email = email;
exports.activitypubNote = activitypubNote;
const fs_extra_1 = require("fs-extra");
const build_1 = require("./build");
const mimeImport = import('mime');
const buster = (_a = require.main) === null || _a === void 0 ? void 0 : _a.require('./src/meta').config['cache-buster'];
const winston = (_b = require.main) === null || _b === void 0 ? void 0 : _b.require('winston');
let metaCache = null;
function clearCache() {
    metaCache = null;
}
const escapeRegExpChars = (text) => text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
async function getTable() {
    if (metaCache) {
        return metaCache;
    }
    const [tableText, aliasesText, asciiText, charactersText,] = await Promise.all([
        (0, fs_extra_1.readFile)(build_1.tableFile, 'utf8'),
        (0, fs_extra_1.readFile)(build_1.aliasesFile, 'utf8'),
        (0, fs_extra_1.readFile)(build_1.asciiFile, 'utf8'),
        (0, fs_extra_1.readFile)(build_1.charactersFile, 'utf8'),
    ]);
    const table = JSON.parse(tableText);
    const aliases = JSON.parse(aliasesText);
    const ascii = JSON.parse(asciiText);
    const characters = JSON.parse(charactersText);
    const asciiPattern = Object.keys(ascii)
        .sort((a, b) => b.length - a.length)
        .map(escapeRegExpChars)
        .join('|');
    const charPattern = Object.keys(characters)
        .sort((a, b) => b.length - a.length)
        .map(escapeRegExpChars)
        .join('|');
    metaCache = {
        table,
        aliases,
        ascii,
        characters,
        asciiPattern: asciiPattern ?
            new RegExp(`(^|\\s|\\n)(${asciiPattern})(?=\\n|\\s|$)`, 'g') :
            /(?!)/,
        charPattern: charPattern ?
            new RegExp(charPattern, 'g') :
            /(?!)/,
    };
    return metaCache;
}
const outsideCode = /(^|<\/code>)([^<]*|<(?!code[^>]*>))*(<code[^>]*>|$)/g;
const outsideElements = /(<[^>]*>)?([^<>]*)/g;
const emojiPattern = /:([a-z\-.+0-9_]+):/g;
const options = {
    ascii: false,
    native: false,
    titles: false,
    baseUrl: '',
};
function setOptions(newOptions) {
    Object.assign(options, newOptions);
}
const buildEmoji = (emoji, whole, mode = null, onReplace = () => { }) => {
    onReplace(emoji, whole);
    if (mode === 'returnChar') {
        return emoji.character || whole;
    }
    if (mode === 'returnWhole') {
        return whole;
    }
    if (emoji.image) {
        const route = `${options.baseUrl}/plugins/nodebb-plugin-emoji/emoji/${emoji.pack}`;
        return `<img
      src="${route}/${emoji.image}?${buster}"
      class="not-responsive emoji emoji-${emoji.pack} emoji--${emoji.name}"
      style="height: 23px; width: auto; vertical-align: middle;"
      title="${whole}"
      alt="${emoji.character}"
    />`;
    }
    return `<span
    class="emoji emoji-${emoji.pack} emoji--${emoji.name}"
    title="${whole}"
  ><span>${emoji.character}</span></span>`;
};
exports.buildEmoji = buildEmoji;
const replaceAscii = (str, { ascii, asciiPattern, table }, mode, onReplace) => str.replace(asciiPattern, (full, before, text) => {
    const emoji = ascii[text] && table[ascii[text]];
    if (emoji) {
        const whole = (mode === 'returnWhole') ? `:${emoji.name}:` : text;
        return `${before}${(0, exports.buildEmoji)(emoji, whole, mode, onReplace)}`;
    }
    return full;
});
const replaceNative = (str, { characters, charPattern, table }, onReplace) => str.replace(charPattern, (char) => {
    const name = characters[char];
    const emoji = table[name];
    if (emoji) {
        return (0, exports.buildEmoji)(emoji, char, null, onReplace);
    }
    return char;
});
async function parse(content, mode = null, onReplace = () => { }) {
    if (!content) {
        return content;
    }
    let store;
    try {
        store = await getTable();
    }
    catch (err) {
        winston.error('[emoji] Failed to retrieve data for parse', err);
        return content;
    }
    const { table, aliases } = store;
    const parsed = content.replace(outsideCode, outsideCodeStr => outsideCodeStr.replace(outsideElements, (_, inside, outside) => {
        let output = outside;
        if (options.native && mode === null) {
            // avoid parsing native inside HTML tags
            // also avoid converting ascii characters
            output = output.replace(/(<[^>]+>)|([^0-9a-zA-Z`~!@#$%^&*()\-=_+{}|[\]\\:";'<>?,./\s\n]+)/g, (full, tag, text) => {
                if (text) {
                    return replaceNative(text, store, onReplace);
                }
                return full;
            });
        }
        output = output.replace(emojiPattern, (whole, text) => {
            const name = text.toLowerCase();
            const emoji = table[name] || table[aliases[name]];
            if (emoji) {
                return (0, exports.buildEmoji)(emoji, whole, mode, onReplace);
            }
            return whole;
        });
        if (options.ascii) {
            // avoid parsing ascii inside HTML tags
            output = output.replace(/(<[^>]+>)|([^<]+)/g, (full, tag, text) => {
                if (text) {
                    return replaceAscii(text, store, mode, onReplace);
                }
                return full;
            });
        }
        return (inside || '') + (output || '');
    }));
    return parsed;
}
function raw(content) {
    return parse(content);
}
async function post(data) {
    if (data.type === 'activitypub.note' || data.type === 'markdown') {
        return data;
    }
    // eslint-disable-next-line no-param-reassign
    data.postData.content = await parse(data.postData.content);
    return data;
}
async function topic(data) {
    if (options.titles) {
        // eslint-disable-next-line no-param-reassign
        data.topic.title = await parse(data.topic.title);
    }
    return data;
}
async function topics(data) {
    if (options.titles) {
        await Promise.all(data.topics.map(async (t) => {
            // eslint-disable-next-line no-param-reassign
            t.title = await parse(t.title);
        }));
    }
    return data;
}
async function postSummaries(data) {
    if (options.titles) {
        await Promise.all(data.posts.map(async (p) => {
            if (p && p.topic && p.topic.title) {
                // eslint-disable-next-line no-param-reassign
                p.topic.title = await parse(p.topic.title);
            }
        }));
    }
    return data;
}
async function notifications(data) {
    if (options.titles) {
        await Promise.all(data.notifications.map(async (n) => {
            if (n && n.bodyShort) {
                // eslint-disable-next-line no-param-reassign
                n.bodyShort = await parse(n.bodyShort);
            }
        }));
    }
    return data;
}
async function header(data) {
    if (!data || !data.templateData || !Array.isArray(data.templateData.metaTags)) {
        return data;
    }
    data.templateData.metaTags.forEach(async (t) => {
        if (t && (t.property === 'og:title' || t.name === 'title')) {
            // eslint-disable-next-line no-param-reassign
            t.content = await parse(t.content, 'returnChar');
        }
    });
    return data;
}
async function email(data) {
    if (data.template === 'notification' && data.params.intro) {
        // eslint-disable-next-line no-param-reassign
        data.params.intro = await parse(data.params.intro, 'returnChar');
    }
    return data;
}
async function activitypubNote(data) {
    const mime = (await mimeImport).default;
    const emojiContext = {
        toot: 'http://joinmastodon.org/ns#',
        Emoji: 'toot:Emoji',
    };
    /* eslint-disable no-param-reassign */
    data.object['@context'] = data.object['@context'] || [];
    if (Array.isArray(data.object['@context'])) {
        data.object['@context'].push(emojiContext);
    }
    else {
        data.object['@context'] = [data.object['@context'], emojiContext];
    }
    data.object.tag = data.object.tag || [];
    data.object.content = await parse(data.object.content, 'returnWhole', (emoji, whole) => {
        if (!emoji.image) {
            return;
        }
        const url = `${options.baseUrl}/plugins/nodebb-plugin-emoji/emoji/${emoji.pack}/${emoji.image}?${buster}`;
        data.object.tag.push({
            id: url,
            type: 'Emoji',
            name: whole,
            icon: {
                type: 'Image',
                mediaType: mime.getType(emoji.image) || '',
                url,
            },
        });
    });
    return data;
}
//# sourceMappingURL=parse.js.map